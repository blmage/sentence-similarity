{"version":3,"file":"index.js","sources":["../src/index.js"],"sourcesContent":["import { _, it, lift } from 'param.macro';\n\n/**\n * @typedef {object} Match\n * @property {number} patternIndex The index of the pattern word.\n * @property {number} stringIndex The index of the string word (-1 if there was no match).\n * @property {number} score The similarity score between the two words (0 if there was no match).\n */\n\n/**\n * @param {string[][]} pattern A list of lists of choices comprised of single words.\n * @param {string[]} string A list of words.\n * @param {Function} compareWords A comparison function for words.\n * @returns {number[][]} A matrix holding the similarity scores for each pair of words.\n */\nfunction getSimilarityMatrix(pattern, string, compareWords) {\n  const similarityMatrix = [];\n\n  for (let i = 0; i < string.length; i++) {\n    similarityMatrix.push([]);\n\n    for (let j = 0; j < pattern.length; j++) {\n      const scores = pattern[j].map(compareWords(_, string[i]));\n      let score = Math.max(...scores);\n      similarityMatrix[i].push(score);\n    }\n  }\n\n  return similarityMatrix;\n}\n\n/**\n * @param {number[][]} similarityMatrix A matrix holding the similarity scores for each pair of words.\n * @returns {Match[]} A list of matches corresponding to the best possible mapping between words.\n */\nfunction findWordMatches(similarityMatrix) {\n  let matches = [];\n  let unMatchedRows = new Set();\n  let unMatchedColumns = new Set();\n\n  for (let i = 0; i < similarityMatrix[0].length; i++) {\n    matches.push({\n      patternIndex: i,\n      stringIndex: -1,\n      score: 0,\n    });\n\n    unMatchedRows.add(i);\n  }\n\n  for (let i = 0; i < similarityMatrix.length; i++) {\n    unMatchedColumns.add(i);\n  }\n\n  let hasChanged = true;\n\n  while (hasChanged && unMatchedRows.size && unMatchedColumns.size) {\n    hasChanged = false;\n\n    for (let row of unMatchedRows) {\n      if (unMatchedColumns.size === 0) {\n        break;\n      }\n\n      let bestColumn = -1;\n      let columnMaxScore = 0;\n\n      for (let column of unMatchedColumns) {\n        let score = similarityMatrix[column][row];\n\n        if (score > columnMaxScore) {\n          columnMaxScore = score;\n          bestColumn = column;\n        }\n      }\n\n      let bestColumnRow = -1;\n      let columnRowMaxScore = 0;\n\n      if (bestColumn >= 0) {\n        for (let columnRow of unMatchedRows) {\n          let score = similarityMatrix[bestColumn][columnRow];\n\n          if (score > columnRowMaxScore) {\n            columnRowMaxScore = score;\n            bestColumnRow = columnRow;\n          }\n        }\n      }\n\n      if (bestColumnRow === row) {\n        matches[bestColumnRow] = {\n          patternIndex: row,\n          stringIndex: bestColumn,\n          score: columnRowMaxScore,\n        };\n\n        hasChanged = true;\n\n        if (bestColumnRow >= 0) {\n          unMatchedRows.delete(bestColumnRow);\n        }\n\n        if (bestColumn >= 0) {\n          unMatchedColumns.delete(bestColumn);\n        }\n      }\n    }\n  }\n\n  return matches;\n}\n\n/**\n * @param {Match[]} matches A list of matches between a pattern and a string.\n * @param {number} stringLength The length of the compared string.\n * @returns {number} A similarity score for the word order.\n */\nfunction getOrderScore(matches, stringLength) {\n  let totalOffset = 0;\n  let matchedCount = 0;\n\n  matches.forEach(({ patternIndex, stringIndex }) => {\n    if (patternIndex >= 0) {\n      matchedCount++;\n      totalOffset += patternIndex - stringIndex;\n    }\n  });\n\n  if (0 === matchedCount) {\n    return 0.0;\n  }\n\n  totalOffset = totalOffset / matchedCount;\n  let orderScore = 0;\n  let totalLength = Math.max(matches.length, stringLength);\n\n  matches.forEach(({ patternIndex, stringIndex }) => {\n    if (patternIndex >= 0) {\n      orderScore += 1.0 - Math.abs(patternIndex - stringIndex - totalOffset) / totalLength;\n    }\n  });\n\n  return (orderScore / matchedCount - 0.5) / 0.5;\n}\n\n/**\n * @param {string[][]} pattern A list of lists of choices comprised of single words.\n * @param {string[]} string A list of words.\n * @param {Function} compareWords A comparison function for words.\n * @returns {number} The similarity score between the pattern and the string.\n */\nfunction getSimilarityScore(pattern, string, compareWords) {\n  const matches = findWordMatches(getSimilarityMatrix(pattern, string, compareWords));\n\n  return (1.0 / string.length)\n    * matches.reduce(lift(_ + _.score), 0)\n    * getOrderScore(matches, string.length);\n}\n\n/**\n * @param {string[][][]} pattern A list of lists of choices comprised of single and/or composite words.\n * @param {string[]} string A list of words.\n * @param {Function} compareWords A comparison function for words.\n * @returns {number} The similarity score between the pattern and the string.\n */\nexport default function compareStringWithPattern(pattern, string, compareWords) {\n  // Find the tokens that contain composite words, if any.\n  const complexTokens = pattern.map(\n    (token, index) => {\n      const [ compositeWords, singleWords ] = partition(\n        token,\n        word => Array.isArray(word) && (word.length > 1)\n      );\n\n      return (0 === compositeWords.length)\n        ? null\n        : {\n          index,\n          choices: compositeWords\n            // Composite words will be used in dedicated patterns, with each part as one single choice.\n            .map(it.map([ it ]))\n            // Single words will be used together as one multiple choice.\n            .concat([ [ singleWords ] ])\n            // Clean everything to make sure we don't end up with redundant patterns.\n            .filter(it.every(it.length > 0))\n        }\n    })\n    .filter(Boolean)\n    .reverse();\n\n  // Build the pattern base comprised of the common tokens.\n  const patternBase = complexTokens.reduce(\n    (result, { index }) => {\n      result.splice(index, 1);\n      return result;\n    },\n    [ ...pattern ]\n  );\n\n  // Build every possible pattern.\n  const patterns = complexTokens.reduce(\n    (result, token, index) => result.flatMap(\n      base => token.choices.map(\n        choice => {\n          const insertAt = token.index - complexTokens.length + index + 1;\n          const subPattern = [ ...base ];\n          subPattern.splice(insertAt, 0, ...choice);\n          return subPattern;\n        }\n      )\n    ),\n    [ patternBase ]\n  );\n\n  // Test each pattern and keep the best score.\n  return patterns.reduce(\n    (bestScore, pattern) => {\n      return (1 === bestScore)\n        ? bestScore\n        : Math.max(\n          bestScore,\n          getSimilarityScore(pattern, string, compareWords)\n        );\n    },\n    0\n  );\n}\n\n/**\n * @param {Array} values A list of values.\n * @param {Function} predicate A predicate.\n * @returns {Array} The given values split into two groups (matching and not matching the predicate).\n */\nfunction partition(values, predicate) {\n  return values.reduce(\n    (result, value) => {\n      result[predicate(value) ? 0 : 1].push(value);\n      return result;\n    },\n    [ [], [] ]\n  )\n}\n"],"names":["pattern","string","compareWords","complexTokens","map","token","index","predicate","word","Array","isArray","length","reduce","result","value","push","compositeWords","singleWords","choices","it","concat","filter","every","Boolean","reverse","patternBase","splice","flatMap","base","choice","insertAt","subPattern","bestScore","Math","max","matches","similarityMatrix","unMatchedRows","Set","unMatchedColumns","i","patternIndex","stringIndex","score","add","hasChanged","size","row","bestColumn","columnMaxScore","column","bestColumnRow","columnRowMaxScore","columnRow","findWordMatches","j","scores","getSimilarityMatrix","_arg3","stringLength","totalOffset","matchedCount","forEach","orderScore","totalLength","abs","getOrderScore","getSimilarityScore"],"mappings":"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"}